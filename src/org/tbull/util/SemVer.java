package org.tbull.util;

import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/** Implements version numbers according to the <A HREF="http://semver.org/">Semantic Versioning</A> (SemVer) recommendation.
 *
 *
 *  Objects of this class are immutable.
 *  {@link #equals(Object)} and {@link #hashCode()} are implemented, so {@code SemVer} objects are suitable for use
 *  as {@link Map} keys.
 *  The natural ordering provided by this class is consistent with equals.
 */

/* also see http://www.jarvana.com/jarvana/view/org/semver/api/0.9/api-0.9-javadoc.jar!/org/semver/package-summary.html
 * for the docs of another implementation. */
public class SemVer implements Comparable<SemVer> {
    protected static final Pattern special_pattern = Pattern.compile("[A-Za-z][0-9A-Za-z-]*");
    protected static final Pattern semver_pattern =
        Pattern.compile("v?(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?([A-Za-z][0-9A-Za-z-]*)?");

    /** The version of this version number implementation. */
    public static final SemVer VERSION = new SemVer(0, 1, 0, "draft");



    public final int major;
    public final int minor;
    public final int patch;
    public final String special;

    private String tostring_cache = null;
    private String totag_cache = null;




    public SemVer(int major, int minor, int patch) {
        this(major, minor, patch, null);
    }

    public SemVer(int major, int minor, int patch, String special) throws IllegalArgumentException {
        if (major < 0) throw new IllegalArgumentException("major version < 0");
        this.major = major;

        if (minor < 0) throw new IllegalArgumentException("minor version < 0");
        this.minor = minor;

        if (patch < 0) throw new IllegalArgumentException("patch level < 0");
        this.patch = patch;

        // TODO the pattern does not match the empty string "" - what to do then?
        if (special != null && !special_pattern.matcher(special).matches())
            throw new IllegalArgumentException("special string does not meet requirements");
        this.special = special;
    }




        private static int cmp(int a, int b) {
            return a < b ? -1 : (a == b ? 0 : 1);
        }

    /* Compares this version with the specified version for order.
     *
     *  @see Comparable#compareTo(Object)
     */
    public @Override int compareTo(SemVer o) {
        int i;

        i = cmp(major, o.major);
        if (i != 0) return i;

        i = cmp(minor, o.minor);
        if (i != 0) return i;

        i = cmp(patch, o.patch);
        if (i != 0) return i;

        if (special == null) return (o.special == null ? 0 : 1);
        if (o.special == null) return -1;
        return special.compareTo(o.special);    // semver spec doesn't say anything about ignoring case differences
    }


    /* Returns a hash code value for the object.
     *
     *  @see Object#hashCode()
     */
    public @Override int hashCode() {
        /* generated by Eclipse */
        final int prime = 31;
        int result = 1;
        result = prime * result + this.major;
        result = prime * result + this.minor;
        result = prime * result + this.patch;
        result = prime * result + ((this.special == null) ? 0 : this.special.hashCode());
        return result;
    }

    /* Indicates whether some other object is "equal to" this one.
     *
     *  @see Object#equals(Object)
     */
    public @Override boolean equals(Object obj) {
        /* generated by Eclipse */
        if (this == obj) return true;
        if (obj == null) return false;
        if (!(obj instanceof SemVer)) return false;
        SemVer other = (SemVer) obj;
        if (this.major != other.major) return false;
        if (this.minor != other.minor) return false;
        if (this.patch != other.patch) return false;
        if (this.special == null) {
            if (other.special != null) return false;
        } else if (!this.special.equals(other.special)) return false;
        return true;
    }


    /** Checks if this version is compatible for use in place of an expected version. (TODO: wording)
     *
     *  <P>The usage goes like this: If you programmed against some version of an API, that version is the
     *  <EM>expected</EM> version (which should be the least version that you know works for you).
     *  {@code this} version (the object that you call the method on) represents the <EM>actual</EM> version that you
     *  found available. Now this method determines if you can use the actual version
     *  of that API in place of the expected one.</P>
     *
     *  <P>For example, if you programmed against an API in version 1.4.2 (the expected version), then this method
     *  would return {@code true} if called on any of the actual versions 1.4.2, 1.4.6 or 1.5.0. It would
     *  return {@code false} if called on any of the actual versions 1.4.0, 1.3.7 or 2.0.0.</P>
     */
    public boolean compatibleForUse(SemVer expected) {
        int cmp = this.compareTo(expected);

        // same version: always compatible
        if (cmp == 0) return true;
        // unstable (initial development) versions must match exactly to be compatible
        if (this.major == 0 || expected.major == 0) return false;
        // actual version smaller than the expected: no good
        if (cmp < 0) return false;
        // actual version is larger (newer) than the required one: usable as long as the major version is the same
        return this.major == expected.major;
    }


    /** Checks if the API with this version is stable.
     *
     *  An API is considered stable as soon as it reaches the first major version (1).
     *
     */
    public boolean isStable() {
        return major > 0;
    }


    public SemVer nextMajor() {
        // TODO
        throw new UnsupportedOperationException("not yet implemented");
    }

    public SemVer nextMinor() {
        // TODO
        throw new UnsupportedOperationException("not yet implemented");
    }

    public SemVer nextPatch() {
        // TODO
        throw new UnsupportedOperationException("not yet implemented");
    }


    public static SemVer parse(CharSequence version) throws IllegalArgumentException {
        int x, y, z;
        String xs, ys, zs;
        String special;

        Matcher m = semver_pattern.matcher(version);
        if (!m.matches()) throw new IllegalArgumentException();

        xs = m.group(1); x = Integer.parseInt(xs);
        ys = m.group(2); y = ys == null ? 0 : Integer.parseInt(ys);
        zs = m.group(3); z = zs == null ? 0 : Integer.parseInt(zs);
        special = m.group(4);
//System.out.printf("semver.parse matched: (%s) (%s) (%s) (%s)\n", xs, ys, zs, special);

        return new SemVer(x, y, z, special);
    }




        private StringBuilder format(StringBuilder sb) {
            sb.append(major).append('.').append(minor).append('.').append(patch);
            if (special != null) sb.append(special);
            return sb;
        }


    /** Returns the version number as a String, as in {@code "X.Y.Zspecial"} */
    public @Override String toString() {
        if (tostring_cache == null)
            tostring_cache = format(new StringBuilder()).toString();
        return tostring_cache;
    }

    /** Returns the version number as a String suitable for use as a version control tag, as in {@code "vX.Y.Zspecial"} */
    public String toTagString() {
        if (totag_cache == null)
            totag_cache = format((new StringBuilder()).append('v')).toString();
        return totag_cache;
    }

}
